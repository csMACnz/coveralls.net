properties {
    # build variables
    $configuration = "Release"	# build configuration
    $script:version = "0.9.0-unstable0005"
    $script:nugetVersion = "0.9.0-unstable0005"

    # directories
    $base_dir = . resolve-path .\
    $project_dir = "$base_dir\src\csmacnz.Coveralls"
    $app_project = "$project_dir\csmacnz.Coveralls.csproj"
    $build_output_dir = "$base_dir\src\csmacnz.Coveralls\bin\$configuration\"
    $build_packages_dir = "$base_dir\BuildPackages\"
    $test_results_dir = "$base_dir\TestResults\"
    $package_dir = "$base_dir\Package\"
    $archive_dir = "$package_dir" + "Archive"
    $nuget_pack_dir = "$package_dir" + "Pack"

    # files
    $sln_file = "$base_dir\csmacnz.Coveralls.sln"
}

Include ".\BuildTools\utils.ps1"

task default

task BootstrapNuget {
    BootstrapNuget "nuget" $build_packages_dir
}

task InstallCoverity -depends BootstrapNuget {
    InstallNugetPackage "PublishCoverity" 0.11.0 $build_packages_dir
}

task InstallGitVersion -depends BootstrapNuget {
    InstallNugetPackage "GitVersion.CommandLine" 5.10.1 $build_packages_dir
}

task InstallReSharperCLI -depends BootstrapNuget {
    InstallNugetPackage "JetBrains.ReSharper.CommandLineTools" 2022.1.1 $build_packages_dir
}

task GitVersion -depends InstallGitVersion {
    $gitVersion = GetGitVersionPath $build_packages_dir
    exec { & $gitVersion /output buildserver /updateassemblyinfo }
    $json = (& $gitVersion) | ConvertFrom-Json
    $script:version = $json.MajorMinorPatch
    $script:nugetVersion = $json.NuGetVersionV2
    ProjectVersion "$project_dir" $script:nugetVersion
}

task AppVeyorEnvironmentSettings {

    if (Test-Path Env:\GitVersion_ClassicVersion) {
        $script:version = $env:GitVersion_ClassicVersion
        Write-Output "version set to $script:version"
    }
    elseif (Test-Path Env:\APPVEYOR_BUILD_VERSION) {
        $script:version = $env:APPVEYOR_BUILD_VERSION
        Write-Output "version set to $script:version"
    }
    if (Test-Path Env:\GitVersion_NuGetVersionV2) {
        $script:nugetVersion = $env:GitVersion_NuGetVersionV2
        Write-Output "nuget version set to $script:nugetVersion"
    }
    elseif (Test-Path Env:\APPVEYOR_BUILD_VERSION) {
        $script:nugetVersion = $env:APPVEYOR_BUILD_VERSION
        Write-Output "nuget version set to $script:nugetVersion"
    }
}

task clean {
    if (Test-Path $package_dir) {
        Remove-Item $package_dir -r
    }
    if (Test-Path $test_results_dir) {
        Remove-Item $test_results_dir -r
    }
    if (Test-Path $build_packages_dir) {
        Remove-Item $build_packages_dir -r
    }
    dotnet clean $sln_file
}

task build {
    exec { dotnet build -c $configuration $sln_file }
}

task setup-coverity-local {
    $env:APPVEYOR_BUILD_FOLDER = "."
    $env:APPVEYOR_BUILD_VERSION = $script:version
    $env:APPVEYOR_REPO_NAME = "csMACnz/coveralls.net"
    "You should have set the COVERITY_TOKEN and COVERITY_EMAIL environment variable already"
    $env:APPVEYOR_SCHEDULED_BUILD = "True"
}

task test-coverity -depends setup-coverity-local, coverity

task coverity -depends InstallCoverity -precondition { return $env:APPVEYOR_SCHEDULED_BUILD -eq "True" } {

    $coverityFileName = "coveralls.coverity.$script:nugetVersion.zip"
    $PublishCoverity = GetCoverityPath $build_packages_dir

    & cov-configure --comptype csc --compiler "C:\Program Files\dotnet\dotnet.exe"
    & cov-build --dir cov-int dotnet msbuild "/t:Clean;Build" "/p:Configuration=$configuration" $sln_file

    if (-not (Test-Path $test_results_dir)) {
        mkdir $test_results_dir
    }

    & $PublishCoverity compress -o $coverityFileName

    & $PublishCoverity publish -t $env:COVERITY_TOKEN -e $env:COVERITY_EMAIL -z $coverityFileName -d "AppVeyor scheduled build ($env:APPVEYOR_BUILD_VERSION)." --codeVersion $script:nugetVersion
}

task unit-test {
    dotnet test .\src\csmacnz.Coveralls.Tests\csmacnz.Coveralls.Tests.csproj
}

task coverage -depends build, coverage-only

task coverage-only {
    if(-not (Test-Path $test_results_dir)) {
        mkdir $test_results_dir
    }

    $coverageOutputFile = "$test_results_dir\Coverage.xml"
    $coverageOutDir = "$test_results_dir\Coverage"
    $tag = $script:nugetVersion
    $coverageResultsZip = "$package_dir\coveralls.coverageResults.$script:nugetVersion.zip"
    
    if(Test-Path $coverageOutDir) {
        Remove-Item $coverageOutDir -r
    }

    if(Test-Path $coverageResultsZip) {
        Remove-Item $coverageResultsZip
    }

    Set-Location "$base_dir\src\csmacnz.Coveralls.Tests"
    exec { dotnet test /p:Configuration=Debug /p:CollectCoverage=true '/p:Include="[csmacnz.Coveralls*]*"' '/p:Exclude="[csmacnz.Coveralls.Tests]AutoGeneratedProgram"' '/p:CoverletOutputFormat=\"json,opencover\"' "/p:CoverletOutput=$coverageOutputFile" } "dotnet test failed"
    Set-Location $base_dir
    dotnet tool restore
    exec { dotnet reportgenerator "-targetdir:$coverageOutDir" "-reports:$coverageOutputFile" "-reportTypes:Html" "-tag:$tag" } "report generator failed"
        
    Add-Type -assembly "system.io.compression.filesystem"
    [io.compression.zipfile]::CreateFromDirectory("$coverageOutDir", "$coverageResultsZip")
}

task test-coveralls -depends archive, coverage {
    exec { & ".\Package\Archive\windows\csmacnz.Coveralls.exe" --opencover -i "$test_results_dir\Coverage.xml" --useRelativePaths --dryrun -o "$test_results_dir\coverallsTestOutput.json" --repoToken "NOTAREALTOKEN" }
}

task coveralls-only -precondition { return -not $env:APPVEYOR_PULL_REQUEST_NUMBER } {
    exec { & ".\Package\Archive\windows\csmacnz.Coveralls.exe" --opencover -i "$test_results_dir\Coverage.xml" --treatUploadErrorsAsWarnings --useRelativePaths}
}

task inspect -depends InstallReSharperCLI {
    $inspectcode = GetInspectCodePath $build_packages_dir
    echo "$inspectcode"
    exec { cmd /c $inspectcode /o="$test_results_dir\resharperReport.xml" $sln_file 2`> nul }
    [xml]$stats = Get-Content $test_results_dir\resharperReport.xml
    $anyErrors = $FALSE;
    $errors = $stats.SelectNodes("/Report/IssueTypes/IssueType")

    foreach ($errorType in $errors) {
        $errorTypeName = $(Get-Culture).TextInfo.ToTitleCase($errorType.Severity.ToLower())
        Write-Host "Found InspectCode $errorTypeName(s): $($errorType.Description)"

        $issues = $stats.SelectNodes("/Report/Issues/Project/Issue[@TypeId='$($errorType.Id)']")
        foreach ($issue in $issues) {
            Write-Host "File: $($issue.File) Line: $($issue.Line) Message: $($issue.Message)"

            if (($errorType.Severity -eq "ERROR") -and (Get-Command "Add-AppveyorTest" -errorAction SilentlyContinue)) {
                Add-AppveyorTest "Resharper Error: $($errorType.Description) Line: $($issue.Line)" -Outcome Failed -FileName "$($issue.File)" -ErrorMessage "$($issue.Message)"
            }
            elseif (Get-Command "Add-AppveyorMessage" -errorAction SilentlyContinue) {
                if ($errorType.Severity -eq "WARNING") {
                    Add-AppveyorMessage "Resharper Warning: $($errorType.Description) File: $($issue.File) Line: $($issue.Line)" -Category Warning -Details "$($issue.Message)"
                }
                else {
                    Add-AppveyorMessage "Resharper $($errorTypeName): $($errorType.Description) File: $($issue.File) Line: $($issue.Line)" -Category Information -Details "$($issue.Message)"
                }
            }
        }
        if ($errorType.Severity -eq "ERROR") {
            $anyErrors = $TRUE
        }
    }

    $xslt = New-Object System.Xml.Xsl.XslCompiledTransform
    $xslt.Load("$base_dir\BuildTools\resharperReport.xslt")
    $xslt.Transform("$test_results_dir\resharperReport.xml", "$test_results_dir\resharperReport.html")

    if (Get-Command "Push-AppveyorArtifact" -errorAction SilentlyContinue) {
        Push-AppveyorArtifact $test_results_dir\resharperReport.xml
        Push-AppveyorArtifact $test_results_dir\resharperReport.html
    }

    if ($anyErrors -eq $TRUE) {
        Write-Host "There are Resharper errors in the solution"
        throw "Resharper errors in the solution"
    }
}

task archive -depends build, archive-only

task archive-only {
    $archive_filename_prefix = "$package_dir\coveralls.net.$script:nugetVersion"
    $linux_archive_filename = "$archive_filename_prefix-linux.zip"
    $windows_archive_filename = "$archive_filename_prefix-windows.zip"
    $osx_archive_filename = "$archive_filename_prefix-osx.zip"
    if(Test-Path $archive_dir) {
        Remove-Item $archive_dir -r
    }
    if(Test-Path $linux_archive_filename) {
        Remove-Item $linux_archive_filename
    }
    
    if(Test-Path $windows_archive_filename) {
        Remove-Item $windows_archive_filename
    }
    
    if(Test-Path $osx_archive_filename) {
        Remove-Item $osx_archive_filename
    }
    mkdir $archive_dir
    dotnet publish $app_project -f net6.0 -c $configuration -o "$archive_dir\windows" -r win-x64 --self-contained -p:PublishSingleFile=true
    dotnet publish $app_project -f net6.0 -c $configuration -o "$archive_dir\linux" -r linux-x64 --self-contained -p:PublishSingleFile=true
    dotnet publish $app_project -f net6.0 -c $configuration -o "$archive_dir\osx" -r osx-x64 --self-contained -p:PublishSingleFile=true
    
    Add-Type -assembly "system.io.compression.filesystem"

    [io.compression.zipfile]::CreateFromDirectory("$archive_dir\windows", $windows_archive_filename)
    [io.compression.zipfile]::CreateFromDirectory("$archive_dir\linux", $linux_archive_filename)
    [io.compression.zipfile]::CreateFromDirectory("$archive_dir\osx", $osx_archive_filename)
}

task pack -depends build, pack-only

task pack-only {
    if(Test-Path $nuget_pack_dir) {
        Remove-Item $nuget_pack_dir -r
    }
    dotnet pack /p:PackageOutputPath=$package_dir /p:PackageVersion=$script:nugetVersion
}

task integration {
    $env:COVERALLSNET_EXEPATH = ""
    dotnet test .\src\csmacnz.Coveralls.Tests.Integration\csmacnz.Coveralls.Tests.Integration.csproj
}

task integration-on-package -depends archive-only {
    $env:COVERALLSNET_EXEPATH = "$base_dir\Package\Archive\windows\csmacnz.Coveralls.exe"
    dotnet test .\src\csmacnz.Coveralls.Tests.Integration\csmacnz.Coveralls.Tests.Integration.csproj
}

task postbuild -depends archive-only, pack-only, coverage-only, coveralls-only, integration, integration-on-package, inspect

task appveyor-install -depends GitVersion

task appveyor-build -depends build

task appveyor-test -depends AppVeyorEnvironmentSettings, postbuild

